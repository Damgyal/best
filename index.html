<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Auto OMR Scanner</title>
<style>
body { margin:0; font-family:system-ui,-apple-system,Roboto,Arial; background:#f4f7fb; }
.container { max-width:500px; margin:auto; padding:1rem; text-align:center; }
#cameraWrapper { position:relative; display:inline-block; width:100%; }
video, canvas { width:100%; border-radius:10px; background:#000; object-fit:cover; }
#a4Overlay { position:absolute; border:2px dashed #1f6feb; pointer-events:none; top:5%; left:5%; width:90%; height:70%; }
#controls { margin-top:10px; display:flex; justify-content:center; gap:10px; flex-wrap:wrap; }
button { padding:10px 20px; border:none; border-radius:50px; background:#1f6feb; color:white; font-weight:600; cursor:pointer; }
button:hover { background:#155ab6; }
.answers { margin-top:15px; }
.answers .row { display:flex; gap:10px; margin-bottom:5px; align-items:center; justify-content:center; }
.answers input { width:40px; text-align:center; border:1px solid #cbd5e1; border-radius:5px; }
#results { margin-top:15px; background:#f9fafb; padding:10px; border-radius:8px; }
</style>
</head>
<body>

<div class="container">
<h2>Auto OMR Scanner</h2>

<div id="cameraWrapper">
    <video id="video" autoplay playsinline></video>
    <canvas id="omrCanvas" style="display:none;"></canvas>
</div>

<div id="controls">
<button id="snapBtn">ðŸ“¸ Snap</button>
<button id="resetBtn">ðŸ”„ Reset</button>
<button id="analyzeBtn" disabled>Analyze</button>
</div>

<div class="answers">
<label>Answer Key:</label>
<div id="answerInputs"></div>
<button id="generateBtn">Generate Answers</button>
</div>

<div id="results"></div>

<script async src="https://docs.opencv.org/4.x/opencv.js"></script>
<script>
const video = document.getElementById("video");
const omrCanvas = document.getElementById("omrCanvas");
const ctx = omrCanvas.getContext("2d");
const snapBtn = document.getElementById("snapBtn");
const resetBtn = document.getElementById("resetBtn");
const analyzeBtn = document.getElementById("analyzeBtn");
const resultsDiv = document.getElementById("results");
const answerInputs = document.getElementById("answerInputs");
const generateBtn = document.getElementById("generateBtn");

let captured = null, scale = 1, offsetX = 0, offsetY = 0, dragging = false, startX = 0, startY = 0;
let correctAnswers = [];

// Start camera
async function startCamera(){
    try{
        const stream = await navigator.mediaDevices.getUserMedia({video:{facingMode:"environment"}});
        video.srcObject = stream;
        await video.play();
    } catch(err){ alert("Camera access needed: "+err);}
}
startCamera();

// Reset camera
resetBtn.addEventListener("click", ()=>{
    captured=null;
    video.style.display="block";
    omrCanvas.style.display="none";
    analyzeBtn.disabled=true;
    scale=1; offsetX=0; offsetY=0;
    ctx.setTransform(1,0,0,1,0,0);
    resultsDiv.innerHTML='';
});

// Generate answer input fields
generateBtn.addEventListener("click", ()=>{
    const numQ = parseInt(prompt("Enter number of questions:", "5"));
    correctAnswers=[];
    answerInputs.innerHTML='';
    for(let i=1;i<=numQ;i++){
        const row = document.createElement("div");
        row.className="row";
        row.innerHTML = `<label>Q${i}:</label><input type="text" maxlength="1" id="ans${i}" placeholder="A-D">`;
        answerInputs.appendChild(row);
    }
});

// Snap image
snapBtn.addEventListener("click", ()=>{
    omrCanvas.width=video.videoWidth;
    omrCanvas.height=video.videoHeight;
    ctx.drawImage(video,0,0,omrCanvas.width,omrCanvas.height);
    captured = ctx.getImageData(0,0,omrCanvas.width,omrCanvas.height);
    analyzeBtn.disabled = true;
    setTimeout(()=>{
        autoWarpAndDetect();
    }, 100); // small delay for opencv loading
    video.style.display="none";
    omrCanvas.style.display="block";
});

// Auto warp and detect OMR sheet
function autoWarpAndDetect(){
    if(!captured) return;
    const src = cv.matFromImageData(captured);
    const gray = new cv.Mat();
    cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
    cv.GaussianBlur(gray, gray, new cv.Size(5,5),0);
    const thresh = new cv.Mat();
    cv.adaptiveThreshold(gray, thresh, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY, 15, 10);

    const contours = new cv.MatVector();
    const hierarchy = new cv.Mat();
    cv.findContours(thresh, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

    let maxArea = 0, pageContour = null;
    for(let i=0;i<contours.size();i++){
        const cnt = contours.get(i);
        const area = cv.contourArea(cnt);
        if(area>maxArea){
            const peri = cv.arcLength(cnt,true);
            const approx = new cv.Mat();
            cv.approxPolyDP(cnt, approx, 0.02*peri, true);
            if(approx.rows===4){ maxArea=area; pageContour=approx;}
            approx.delete();
        }
        cnt.delete();
    }
    if(!pageContour){ alert("Could not detect OMR sheet. Adjust lighting or zoom."); src.delete(); gray.delete(); thresh.delete(); contours.delete(); hierarchy.delete(); return;}

    // Warp
    const pts = [];
    for(let i=0;i<4;i++) pts.push({x:pageContour.intAt(i,0), y:pageContour.intAt(i,1)});
    pts.sort((a,b)=>a.y-b.y);
    const top = [pts[0], pts[1]].sort((a,b)=>a.x-b.x);
    const bottom = [pts[2], pts[3]].sort((a,b)=>a.x-b.x);
    const srcPts = cv.matFromArray(4,1,cv.CV_32FC2,[top[0].x,top[0].y, top[1].x,top[1].y, bottom[1].x,bottom[1].y, bottom[0].x,bottom[0].y]);
    const width=Math.max(bottom[1].x-bottom[0].x, top[1].x-top[0].x);
    const height=Math.max(bottom[0].y-top[0].y, bottom[1].y-top[1].y);
    const dstPts = cv.matFromArray(4,1,cv.CV_32FC2,[0,0,width,0,width,height,0,height]);
    const M = cv.getPerspectiveTransform(srcPts,dstPts);
    const warpedMat = new cv.Mat();
    cv.warpPerspective(src, warpedMat, M, new cv.Size(width,height));

    cv.imshow(omrCanvas, warpedMat);

    src.delete(); gray.delete(); thresh.delete(); contours.delete(); hierarchy.delete(); pageContour.delete(); srcPts.delete(); dstPts.delete(); M.delete();

    warped = warpedMat;
    analyzeBtn.disabled = false;
}

// AI-style OMR detection
function detectOMRAnswers(img,numQuestions){
    const gray = new cv.Mat();
    cv.cvtColor(img, gray, cv.COLOR_RGBA2GRAY);
    cv.GaussianBlur(gray, gray, new cv.Size(5,5),0);
    const thresh = new cv.Mat();
    cv.adaptiveThreshold(gray, thresh, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY_INV, 31, 10);

    const contours = new cv.MatVector(), hierarchy = new cv.Mat();
    cv.findContours(thresh, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

    let bubbles = [];
    for(let i=0;i<contours.size();i++){
        const cnt = contours.get(i);
        const rect = cv.boundingRect(cnt);
        const aspect = rect.width/rect.height;
        const area = rect.width*rect.height;
        if(aspect>0.7 && aspect<1.3 && area>200 && area<2000) bubbles.push({x:rect.x+rect.width/2, y:rect.y+rect.height/2, rect});
        cnt.delete();
    }

    bubbles.sort((a,b)=>a.y-b.y);
    const grouped=[], yThreshold=20;
    for(const b of bubbles){
        let found=false;
        for(const g of grouped){
            if(Math.abs(g[0].y-b.y)<yThreshold){ g.push(b); found=true; break;}
        }
        if(!found) grouped.push([b]);
    }
    grouped.forEach(row=>row.sort((a,b)=>a.x-b.x));

    const answers=[];
    const rows=Math.min(numQuestions, grouped.length);
    for(let i=0;i<rows;i++){
        const row=grouped[i];
        const shades=[];
        for(let j=0;j<row.length;j++){
            const r=row[j].rect;
            const roi=thresh.roi(r);
            const fill=cv.countNonZero(roi)/(r.width*r.height);
            shades.push({idx:j,fill});
            roi.delete();
        }
        const maxFill=Math.max(...shades.map(s=>s.fill));
        const marked=shades.filter(s=>s.fill>maxFill*0.8);
        if(marked.length===0) answers.push("None");
        else if(marked.length>1) answers.push("Multiple");
        else answers.push(["A","B","C","D"][marked[0].idx]||"?");
    }

    gray.delete(); thresh.delete(); contours.delete(); hierarchy.delete();
    return answers;
}

let warped=null;
analyzeBtn.addEventListener("click", ()=>{
    if(!warped){ alert("Warped image not ready"); return;}
    const numQ = correctAnswers.length;
    for(let i=1;i<=numQ;i++){
        const val=document.getElementById("ans"+i)?.value.trim().toUpperCase();
        if(!val.match(/^[A-D]$/)){ alert("Enter valid answers A-D"); return;}
        correctAnswers[i-1]=val;
    }

    const detected = detectOMRAnswers(warped,numQ);
    let score=0;
    const details=[];
    for(let i=0;i<numQ;i++){
        let stu = detected[i];
        let status = "âŒ";
        if(stu===correctAnswers[i]){ status="âœ…"; score++; }
        details.push(`<tr><td>${i+1}</td><td>${stu}</td><td>${correctAnswers[i]}</td><td>${status}</td></tr>`);
    }
    resultsDiv.innerHTML=`<h3>Results</h3>
        <table border="1" cellspacing="0" cellpadding="6">
        <tr><th>Q#</th><th>Student</th><th>Correct</th><th>Status</th></tr>
        ${details.join("")}</table>
        <p>Score: ${score}/${numQ}</p>`;
});
</script>
</body>
</html>
